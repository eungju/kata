![문제로 풀어보는 알고리즘](http://www.insightbook.co.kr/wp-content/uploads/2012/07/8966260462_f21.jpg)

간단하게 요약하면 공집합을 제외한 모든 부분집합을 구하는 문제다.

어떤 집합의 부분집합들을 어떻게 구하는가? 우선 공집합의 부분집합부터 구해보자.

~~~
subsets({}) = {{}}
~~~

공집합의 부분집합은 공집합 하나뿐이다.

그럼 원소가 하나인 집합의 부분집합을 구해보자. 원소를 포함하지 않은 경우와, 포함한 경우 두 개의 부분집합이 있다.

~~~
subsets({0}) = {{}, {0}}
~~~

원소가 둘인 집합의 경우도 생각해보자.

~~~
subsets({0,1}) = {{}, {0}, {1}, {0,1}}
~~~

두 원소 모두 포함하지 않은 경우, 0은 포함하고, 1은 포함하지 않은 경우, 모두 포함한 경우로 나눌 수 있다. 표로 그려보면 다음과 같다.

1 | 0
- | -
X | X
X | O
O | X
O | O

원소가 세 개인 경우는 크기가 두 배가 되고 2가 선택된 경우와 아닌 경우로 나뉜다.

2 | 1 | 0
- | - | -
X | X | X
X | X | O
X | O | X
X | O | O
O | X | X
O | X | O
O | O | X
O | O | O

원소가 하나인 경우는 크기가 반으로 줄어 든다.

| 0 |
| - |
| X |
| O |

규칙이 보인다.

어떤 원소를 포함하지 않은 부분집합을 구하는 문제와, 어떤 원소를 포함한 부분집합을 구하는 문제로 문제의 크기를 줄일 수 있다. 

Erlang 코드로 표한하면 다음과 같다.

~~~
subsets([]) ->
    [[]];
subsets([H|L]) ->
    S = subsets(L),
    lists:append(S, lists:map(fun(X) -> [H|X] end, S)).
~~~

문제에서는 공집합이 포함되지 않아야 하고 n이 주어지면 0부터 n-1까지의 숫자가 원소가 된다. 주어진 문제를 풀기 위한 코드는 다음과 같다.

~~~
-module(insightevent2).
-compile(export_all).

subsets([]) ->
    [[]];
subsets([H|L]) ->
    S = subsets(L),
    lists:append(S, lists:map(fun(X) -> [H|X] end, S)).

solve(N) ->
    [_|S] = subsets(lists:seq(0,N-1)),
    S.
~~~
